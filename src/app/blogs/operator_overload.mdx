import Alert from "../components/md/Alert/index";

export const meta = {
    name: "Operator overloading",
    date: "011 November, 2022",
    tag: "c++"
}

# C++ operator overloading

In c++, we can add extra functionality to user-defined objects or structs by redefining/overloading built in c++ operators. This could become handy for syntacticaly sugar, making our code intuitive and easy to understand. In this tutorial, I am going to explain the basics of operator overloading to make you have a clear understanding about this *huge* topic.

Here are some examples about how it can be used:

```cpp
// My mind blew out when I discovered this one with (std::fs::path)
auto path3 = path1 / path2; // instead of path1->join(path2)

// auto result = calcValue1.addWith(calcValue2)
auto resut = calcValue1 + calcValue2 // you get the idea...
```

<Alert type="info">
    **Does not work with basic data types!**

    Operator overloading can't be applied to basic data types (int, char, ...)
</Alert>

## How to declare an operator

    To declare an operator, the c++ developers created one of the most creative keywords to use (`operator`). And you can treat it like a normal function.

The syntax of an operator would be:
- `[return type] operator [operator] ([args) { ... }`


## Unary operators

Unary operators are operators with only one operand, meaning that they declarations should not contain any arguments.

Types of unary operators:
- unary minus(-)
- increment(++)
- decrement(--)
- NOT(!)
- Addressof operator(&)
- sizeof()

## Examples

Let's imagine, you are creating a vector class. You want to be able to sum those classes.

```cpp
#include <utility>

class Vector {
    std::pair<int /*x*/, int /*y*/> coordinates;

    void setValues(int x, int y) {
        this->coordinates = { x, y };
    }

    Vector operator+ (const Vector& p_vec2) {
        Vector vec;
        vec.coordinates = {
            this->coordinates.first  + p_vec2.coordinates.first,
            this->coordinates.second + p_vec2.coordinates.second
        };

        return vec;
    }
}

int main() {
    Vector vec1;
    vec1.setvalues(1, 2);

    Vector vec2;
    vec2.setvalues(5, 4);

    auto vec3 = vec1 + vec2;
    // vec3.coordinates == {6, 6}

    return 0;
}
```

Here are some more detailed examples (external):
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/class_member_access_operator_overloading.htm">Unary Operators Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/binary_operators_overloading.htm">Binary Operators Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/relational_operators_overloading.htm">Relational Operators Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/input_output_operators_overloading.htm">Input/Output Operators Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/increment_decrement_operators_overloading.htm">++ and -- Operators Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/assignment_operators_overloading.htm">Assignment Operators Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/function_call_operator_overloading.htm">Function call () Operator Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/subscripting_operator_overloading.htm">Subscripting [] Operator Overloading</a>
- <a target="_blank" href="https://www.tutorialspoint.com/cplusplus/class_member_access_operator_overloading.htm">Class Member Access Operator -> Overloading</a>
